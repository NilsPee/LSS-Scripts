// ==UserScript==
// @name         LS Button for assigning people
// @namespace    http://tampermonkey.net/
// @version      1.7
// @description  Weist mit einem Klick allen Fahrzeugen automatisch passendes Personal zu, nur mit richtiger Ausbildung und mit Vorgabe der Menge. Fahrzeuge ohne Ausbildung werden direkt übersprungen und Überhänge korrigiert.
// @author       Kruemmel & NilsPe
// @match        https://www.leitstellenspiel.de/buildings/*
// @grant        none
// ==/UserScript==

(async function () {
  'use strict';

  const PER_PERSON_DELAY_MS = 120; // kurze Pause je Aktion
  const PER_VEHICLE_DELAY_MS = 180; // Pause zwischen Fahrzeugen

  // --- Eigene Konfiguration: Fahrzeug-Typ-ID => gewünschte Personenanzahl ---
  const FORCE_ASSIGN = {
    12: 1,

    27: 1,
    29: 2,
    31: 1,
    33: 1,
    34: 1,
    35: 1,
    40: 1,
    42: 1,
    45: 1,
    46: 1,
    51: 1,
    53: 6,
    55: 1,
    56: 1,
    57: 1,
    59: 1,
    60: 1,
    61: 1,
    63: 1,
    64: 1,
    69: 1,
    72: 1,
    74: 2,
    75: 1,
    76: 1,
    79: 1,
    80: 1,
    81: 1,
    82: 1,
    83: 1,
    84: 1,
    85: 1,
    86: 1,
    91: 1,
    93: 1,
    94: 1,
    95: 1,
    98: 1,
    99: 1,
    100: 1,
    103: 1,
    109: 1,
    122: 1,
    123: 1,
    125: 1,
    126: 1,
    127: 1,
    128: 1,
    131: 1,
    133: 1,
    134: 1,
    135: 1,
    137: 1,
    140: 1,
    144: 1,
    145: 1,
    147: 1,
    148: 4,
    149: 1,
    151: 1,
    153: 1,
    158: 1,
    162: 1,
    163: 1,
    164: 1,
    165: 1,
  };

  function addButtonIfMissing() {
    if ($("#vehicle_table").length && !$("#assignAllPersonnel").length) {
      $("#vehicle_table").before(`
        <a class="btn btn-primary btn-xs" id="assignAllPersonnel">
          Personal zuweisen (alle Fahrzeuge)
        </a>
        <div id="assignStatus" style="margin-top:5px; font-weight:bold;"></div>
        <div id="assignLog" style="margin-top:5px; font-family:monospace; white-space:pre-line; margin-top:6px; max-height:300px; overflow:auto;"></div>
      `);

      $("#assignAllPersonnel").on("click", function () {
        $("#assignAllPersonnel").addClass("disabled");
        assignAllVehicles().finally(() => $("#assignAllPersonnel").removeClass("disabled"));
      });
    }
  }
  setInterval(addButtonIfMissing, 1500);

  async function assignAllVehicles() {
    const rows = Array.from($("#vehicle_table tbody tr"));
    const total = rows.length;
    let processed = 0;

    $("#assignLog").text("");
    for (const row of rows) {
      const vehId = getVehicleID(row);
      try {
        const result = await assignVehicle(vehId);
        logVehicle(result);
      } catch (e) {
        console.warn("Fehler bei Fahrzeug " + vehId, e);
        logVehicle({ id: vehId, assigned: 0, cap: 0, error: true, message: e && e.message, wanted: 0 });
      }

      processed++;
      updateStatus(processed, total);
      await delay(PER_VEHICLE_DELAY_MS);
    }

    $("#assignAllPersonnel")[0].innerHTML = "Personal wurde zugewiesen";
    $("#assignStatus").text("Fertig! Seite lädt in 5 Sekunden neu...");
    setTimeout(() => location.reload(), 5000);
  }

  function updateStatus(done, total) {
    $("#assignStatus").text(`Bearbeitet: ${done} / ${total}`);
  }

  function logVehicle({ id, assigned, cap, error, message, wanted }) {
    let msg, color;

    if (error) {
      msg = `Fahrzeug ${id}: Fehler beim Zuweisen${message ? " — " + message : ""}`;
      color = "red";
    } else if (message && message.startsWith("Übersprungen")) {
      msg = `Fahrzeug ${id}: ${message}`;
      color = "gray";
    } else if (assigned === wanted) {
      msg = `Fahrzeug ${id}: ${assigned}/${wanted} besetzt (voll besetzt)`;
      color = "green";
    } else if (assigned < wanted) {
      msg = `Fahrzeug ${id}: ${assigned}/${wanted} besetzt (nicht voll)`;
      color = "orange";
    } else if (assigned > wanted) {
      msg = `Fahrzeug ${id}: ${assigned}/${wanted} besetzt (zu viele, korrigiert)`;
      color = "orange";
    } else {
      msg = `Fahrzeug ${id}: ${assigned}/${cap} besetzt (keine Zuweisung erfolgt)`;
      color = "gray";
    }

    $("#assignLog").append(`<span style="color:${color}">${msg}</span>\n`);
  }

  function getVehicleID(e) {
    return e.getElementsByTagName("td")[1]
      .getElementsByTagName("a")[0]
      .getAttribute("href")
      .replace(/\D/g, "");
  }

  // ---- Hilfsfunktionen ----
  async function fetchAssignDoc(vehicleId) {
    const resp = await fetch(`/vehicles/${vehicleId}/zuweisung`, {
      headers: { "x-requested-with": "XMLHttpRequest" },
      credentials: "same-origin",
    });
    if (!resp.ok) throw new Error("Zuweisungsseite nicht erreichbar: " + resp.status);
    const html = await resp.text();
    const parser = new DOMParser();
    return parser.parseFromString(html, "text/html");
  }

  function parseCap(doc) {
    const el = doc.querySelector("#count_personal");
    if (!el) return { assignedCapRaw: 0, cap: 0 };
    const text = el.parentElement?.textContent || "";
    const m = text.match(/(\d+)\s*\/\s*(\d+)/);
    if (!m) return { assignedCapRaw: 0, cap: 0 };
    return { assignedCapRaw: parseInt(m[1]) || 0, cap: parseInt(m[2]) || 0 };
  }

  function isRowMatching(row, identifier) {
    if (identifier) {
      const dfb = row.getAttribute("data-filterable-by") || "";
      return dfb.includes(identifier);
    } else {
      const qualText = (row.children?.[1]?.innerText || "").trim().toLowerCase();
      return qualText === "" || qualText === "-";
    }
  }

  function collectRows(doc, identifier) {
    const rows = Array.from(doc.querySelectorAll("tr"));
    const boundMatchingRows = rows.filter(r => r.querySelector("a.btn-assigned") && isRowMatching(r, identifier));
    const candidateRows = rows.filter(r => {
      const btn = r.querySelector("a.btn-success");
      if (!btn) return false;
      if (!isRowMatching(r, identifier)) return false;
      const col = r.children?.[2];
      return !(col && col.innerText.trim().startsWith("Im Unterricht"));
    });
    return { boundMatchingRows, candidateRows };
  }

  async function assignVehicle(vehicleId) {
    // 1) vehicle_type via API
    let vehicleTypeId = null;
    try {
      const vresp = await fetch(`/api/v2/vehicles/${vehicleId}`, { credentials: "same-origin" });
      if (!vresp.ok) throw new Error("Vehicle API nicht erreichbar: " + vresp.status);
      const vjson = await vresp.json();
      vehicleTypeId = vjson.result && vjson.result.vehicle_type;
    } catch (e) {
      throw new Error("Fehler beim Abfragen des vehicle_type: " + e.message);
    }

    // 2) Nur Fahrzeuge aus FORCE_ASSIGN bearbeiten
    if (FORCE_ASSIGN[vehicleTypeId] === undefined) {
      return { id: vehicleId, assigned: 0, cap: 0, error: false, message: "Übersprungen (nicht in Liste)", wanted: 0 };
    }
    const wanted = FORCE_ASSIGN[vehicleTypeId];
    const identifier = getIdentifierByVehicleTypeId(vehicleTypeId);
    const csrf = document.querySelector("meta[name=csrf-token]")?.content || "";
    const headers = {
      "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
      "x-csrf-token": csrf,
      "x-requested-with": "XMLHttpRequest",
    };

    // 3) Seite holen + zählen
    let doc = await fetchAssignDoc(vehicleId);
    let { cap } = parseCap(doc);
    let { boundMatchingRows, candidateRows } = collectRows(doc, identifier);
    let assignedMatching = boundMatchingRows.length;

    // 4) Überhang abbauen
    if (assignedMatching > wanted) {
      let toRemove = assignedMatching - wanted;
      for (const row of [...boundMatchingRows].reverse()) {
        if (toRemove <= 0) break;
        const delLink = row.querySelector("a.btn-assigned");
        if (!delLink) continue;

        try {
          const r = await fetch(delLink.href, { method: "POST", headers, credentials: "same-origin" });
          if (r.ok) {
            toRemove--;
            await delay(PER_PERSON_DELAY_MS);
            doc = await fetchAssignDoc(vehicleId);
            ({ cap } = parseCap(doc));
            ({ boundMatchingRows, candidateRows } = collectRows(doc, identifier));
            assignedMatching = boundMatchingRows.length;
          }
        } catch (e) {
          console.warn("Fehler beim Entfernen", e);
        }
      }
    }

    // 5) Fehlende auffüllen
    if (assignedMatching < wanted) {
      let need = wanted - assignedMatching;
      for (const row of candidateRows) {
        if (need <= 0) break;
        const btn = row.querySelector("a.btn-success");
        if (!btn) continue;

        let ok = false;
        for (let attempt = 0; attempt < 3; attempt++) {
          try {
            const r = await fetch(btn.href, { method: "POST", headers, credentials: "same-origin" });
            if (r.ok) { ok = true; break; }
            await delay(r.status === 429 ? 1000 : 200);
          } catch { await delay(200); }
        }
        if (ok) {
          need--;
          await delay(PER_PERSON_DELAY_MS);
          doc = await fetchAssignDoc(vehicleId);
          ({ cap } = parseCap(doc));
          ({ boundMatchingRows, candidateRows } = collectRows(doc, identifier));
          assignedMatching = boundMatchingRows.length;
        }
      }
    }

    return { id: vehicleId, assigned: assignedMatching, cap, error: false, message: "", wanted };
  }

  function delay(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  // --- Identifier-Mapping ---
  function getIdentifierByVehicleTypeId(vehicleTypeId) {
    switch (vehicleTypeId) {
      case 12: return "gw_messtechnik";
      case 27: return "gw_gefahrgut";
      case 29: return "notarzt";
      case 31: return "notarzt";
      case 33: return "gw_hoehenrettung";
      case 34: return "elw2";
      case 35: return "police_einsatzleiter";
      case 40: return "thw_zugtrupp";
      case 42: return "thw_raumen";
      case 45: return "thw_raumen";
      case 46: return "wechsellader";
      case 51: return "police_fukw";
      case 53: return "dekon_p";
      case 55: return "lna";
      case 56: return "orgl";
      case 57: return "fwk";
      case 59: return "seg_elw";
      case 60: return "seg_gw_san";
      case 61: return "polizeihubschrauber";
      case 63: return "gw_taucher";
      case 64: return "gw_wasserrettung";
      case 69: return "gw_taucher";
      case 72: return "police_wasserwerfer";
      case 74: return "notarzt";
      case 75: return "arff";
      case 76: return "rettungstreppe";
      case 79: return "police_sek";
      case 80: return "police_sek";
      case 81: return "police_mek";
      case 82: return "police_mek";
      case 83: return "werkfeuerwehr";
      case 84: return "werkfeuerwehr";
      case 85: return "werkfeuerwehr";
      case 86: return "werkfeuerwehr";
      case 91: return "seg_rescue_dogs";
      case 93: return "thw_rescue_dogs";
      case 94: return "k9";
      case 95: return "police_motorcycle";
      case 98: return "criminal_investigation";
      case 99: return "water_damage_pump";
      case 100: return "water_damage_pump";
      case 103: return "police_service_group_leader";
      case 109: return "heavy_rescue";
      case 122: return "thw_energy_supply";
      case 123: return "water_damage_pump";
      case 125: return "thw_drone";
      case 126: return "fire_drone";
      case 127: return "seg_drone";
      case 128: return "fire_drone";
      case 131: return "care_service";
      case 133: return "care_service_equipment";
      case 134: return "police_horse";
      case 135: return "police_horse";
      case 137: return "police_horse";
      case 140: return "fire_care_service";
      case 144: return "thw_command";
      case 145: return "thw_command";
      case 147: return "thw_command";
      case 148: return "thw_command";
      case 149: return "notarzt";
      case 151: return "mountain_command";
      case 153: return "seg_rescue_dogs";
      case 158: return "mountain_height_rescue";
      case 162: return "railway_fire";
      case 163: return "railway_fire";
      case 164: return "railway_fire";
      case 165: return "police_speaker_operator";
      default: return null;
    }
  }

})();
